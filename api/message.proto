syntax = "proto3";
package braid;

option go_package = "github.com/vsekhar/braid/pkg/api/braidpb";

import "google/protobuf/timestamp.proto";

message Message {
    Authorship authorship = 1;
    Timestamp timestamp = 2;
    Parentage parentage = 3;
    ApplicationData data = 4;
}

// Authorship identifies a particular message author and the committed state
// that author was in when authoring a given message.
message Authorship {
    Signature signature = 1;
    HorizonCommitment horizon_commitment = 2;
}

message Signature {
    Ed25519KeyAndSignature ed25519_v1 = 1;
}

message Ed25519KeyAndSignature {
    bytes public_key = 1;
    bytes signature = 2; // == sign(Ref(Message).shake256_64_v1)
}

message HorizonCommitment {
    HorizonRef ref = 1;
    ApplicationRef application = 2;
}

message MessageSetRef {
    // shake256_64_v1 for a set of messages is the SHAKE256 hash of the Ref's of
    // each of the messages in the set. The set is ordered first by increasing
    // timestamp, and ties are broken by increasing message hash value
    // (Ref(message).shake256_64_v1).
    bytes shake256_64_v1 = 1;
}

message HorizonRef {
    MessageSetRef messages = 1;

    // It is infeasible to try every possible combination of messages to
    // reconstruct and verify a given horizon, therefore every HorizonRef (and
    // by extension every message) must include and store the timestamp of the
    // most recent entry included in the horizon.
    //
    // This timestamp refers to a historical state of the braid, rather than the
    // ordering of any message, so it does not need a timestamp proof.
    google.protobuf.Timestamp timestamp = 2;
}

message FrontierRef {
    MessageSetRef messages = 1;
}

// ApplicationRef is a reference to a state of the application at a given
// horizon.
message ApplicationRef {
    bytes ref = 1;
}

message Timestamp {
    google.protobuf.Timestamp timestamp = 1;
    // TODO proof
}

message Parentage {
    repeated Parent parents = 1;
}

message Parent {
    MessageRef ref = 1;
    uint64 contribution = 2;
}

message MessageRef {
    // shake256_64_v1 for a message is the SHAKE256 hash of its:
    //
    //   1) message.authorship.signature.ed25519_v1.public_key
    //        - omitted: signature
    //   2) message.authorship.horizon_commitment
    //        .timestamp
    //        .ref
    //        .application
    //   3) message.timestamp.timestamp:
    //   3) message.parentage.parents[i].parent.shake256_64_v1
    //        - omitted: contribution
    //   4) message.data.data
    //
    // Timestamps are hashed as:
    //  - little-endian binary encoding of UTC seconds since the Unix epoch (8 bytes)
    //  - little-endian binary encoding of UTC nanoseconds (4 bytes)
    //  - omitted: proof (if any)
    //
    // output of 64 bytes is then obtained from the sponge.
    //
    // No data is written for a field that is empty or the zero timestamp.
    bytes shake256_64_v1 = 1;
}

message ApplicationData {
    bytes data = 1;
}

message RequestMessages {
    repeated MessageRef want = 1;

    // Frontier of the requesting node so that the responding node can also
    // send other messages the requesting node might need (e.g. the transitive
    // parents of the messages in want). May be omitted.
    FrontierRef frontier = 2;
}
